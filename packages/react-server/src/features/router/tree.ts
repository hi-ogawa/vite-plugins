import { sortBy, tinyassert } from "@hiogawa/utils";
import type { RouteModule, RouteModuleTree } from "./server";
import { getPathPrefixes } from "./utils";

// generate tree from glob entries such as generated by
//   import.meta.glob("/**/(page|layout|...).(js|jsx|ts|tsx)")
export function createFsRouteTree<T>(globEntries: Record<string, unknown>): {
  entries: Record<string, T>;
  tree: TreeNode<T>;
} {
  const entries: Record<string, T> = {};
  for (const [k, v] of Object.entries(globEntries)) {
    const m = k.match(
      /^(.*)\/(page|layout|error|not-found|loading|template|route)\.\w*$/,
    );
    tinyassert(m && 1 in m && 2 in m);
    const pathname = m[1] || "/";
    (entries[pathname] ??= {} as any)[m[2]] = v;
  }

  const flatTree = Object.entries(entries).map(([k, v]) => ({
    keys: k.replace(/\/+$/, "").split("/"),
    value: v,
  }));
  const tree = createTree(flatTree);

  // sort to match static route first before dynamic route
  sortDynamicRoutes(tree);

  return { entries, tree };
}

function sortDynamicRoutes<T>(tree: TreeNode<T>) {
  if (tree.children) {
    tree.children = Object.fromEntries(
      sortBy(Object.entries(tree.children), ([k]) => k.includes("[")),
    );
    for (const v of Object.values(tree.children)) {
      sortDynamicRoutes(v);
    }
  }
}

export type MatchParamEntry = [key: string | null, value: string];
export type MatchParams = Record<string, string>;

export function toMatchParamsObject(params: MatchParamEntry[]): MatchParams {
  let result: MatchParams = {};
  for (const [k, v] of params) {
    if (k) {
      result[k] = v;
    }
  }
  return result;
}

export type MatchNodeEntry<T> = {
  prefix: string;
  type: MatchNodeType;
  node: TreeNode<T>;
  params: MatchParamEntry[];
};

type MatchNodeType = "layout" | "page" | "not-found";

export function toRouteId(pathname: string, type: MatchNodeType) {
  return pathname + ":" + type;
}

export type MatchResult<T> = {
  matches: MatchNodeEntry<T>[];
  params: MatchParamEntry[];
  notFound: boolean;
};

// TODO:
// - if "not found", then don't render layouts after the closes not-found
//   - so we probably want to write this recursively with the information of RouteModuleTree
// - we want to use less-general RouteModuleTree based match, but
//   but that would prevent it to reuse for other
//   e.g. `route.js` match or preload match

export function matchRouteTree<T>(
  tree: TreeNode<T>,
  pathname: string,
): MatchResult<T> {
  const prefixes = getPathPrefixes(pathname);

  let node = tree;
  const params: MatchParamEntry[] = []; // TODO: remove
  const matches: MatchNodeEntry<T>[] = [];
  let notFound = false;
  for (let i = 0; i < prefixes.length; i++) {
    const prefix = prefixes[i]!;
    const segment = prefix.split("/").at(-1)!;
    const next = matchRouteChild(segment, node);
    if (next) {
      node = next.child;
      if (next.catchAll) {
        const rest = pathname.slice(prefixes[i - 1]!.length + 1);
        params.push([next.param, decodeURI(rest)]);
        matches.push({ prefix: pathname, type: "layout", node, params });
        // matches.push({ prefix: pathname, type: "page", node, params });
        break;
      }
      if (next.param) {
        params.push([next.param, decodeURI(segment)]);
      } else {
        params.push([null, decodeURI(segment)]);
      }
    } else {
      // matches.push({ prefix, type: "not-found", node, params });
      notFound = true;
      break;
    }
    matches.push({ prefix, type: "layout", node, params });
    // if (prefix === pathname) {
    //   matches.push({ prefix, type: "page", node, params });
    // }
  }
  return { matches, params, notFound };
}

export function matchRouteTree3(tree: RouteModuleTree, pathname: string) {
  const prefixes = getPathPrefixes(pathname);
  tree;
  pathname;
  prefixes;

  function recurse(
    node: RouteModuleTree,
    cursor: number,
    params: MatchParamEntry[],
    matches: MatchNodeEntry<RouteModule>[],
  ) {
    node;
    params;
    matches;

    if (cursor === prefixes.length) {
      if (node.value?.page) {
        // add self
        // do what?
      } else {
        // return not found
      }
      return;
    }

    const prefix = prefixes[cursor]!;
    const segment = prefix?.split("/").at(-1)!;

    for (const [key, child] of Object.entries(node.children ?? {})) {
      const mAll = key.match(CATCH_ALL_RE);
      if (mAll) {
        tinyassert(1 in mAll);
        const newParams: MatchParamEntry[] = [...params, [mAll[1], segment]];
        newParams;
        segment;
      }

      const m = key.match(DYNAMIC_RE);
      if (m) {
        tinyassert(1 in m);
        const newParams: MatchParamEntry[] = [...params, [m[1], segment]];
        const newMatches: MatchNodeEntry<RouteModule>[] = [
          ...matches,
          { prefix, type: "layout", node: child, params: newParams },
        ];
        recurse(child, cursor + 1, newParams, newMatches);
      }

      if (key === segment) {
        const newParams: MatchParamEntry[] = [...params, [null, segment]];
        newParams;
        // recurse(child, cursor + 1, {
        //   params: newParams,
        //   matches: [
        //     ...matches,
        //     { prefix, type: "layout", node: child, params: newParams },
        //   ],
        // })
      }
    }

    // return not found
  }

  recurse;

  //   const prefixes = getPathPrefixes(pathname);

  //   let node = tree;
  //   const params: MatchParamEntry[] = [];
  //   const matches: MatchNodeEntry<RouteModuleTree>[] = [];
  //   let notFound = false;
  //   for (let i = 0; i < prefixes.length; i++) {
  //     const prefix = prefixes[i]!;
  //     const segment = prefix.split("/").at(-1)!;
  //     const next = matchRouteChild(segment, node);
  //     if (next) {
  //       node = next.child;
  //       if (next.catchAll) {
  //         const rest = pathname.slice(prefixes[i - 1]!.length + 1);
  //         params.push([next.param, decodeURI(rest)]);
  //         matches.push({ prefix: pathname, type: "layout", node, params });
  //         break;
  //       }
  //       if (next.param) {
  //         params.push([next.param, decodeURI(segment)]);
  //       } else {
  //         params.push([null, decodeURI(segment)]);
  //       }
  //     } else {
  //       matches.push({ prefix, type: "not-found", node, params });
  //       notFound = true;
  //       break;
  //     }
  //     matches.push({ prefix, type: "layout", node, params });
  //     if (prefix === pathname) {
  //       if (node.value?.page) {
  //         matches.push({ prefix, type: "page", node, params });
  //       } else {
  //         matches.push({ prefix, type: "not-found", node, params });
  //         notFound = true;
  //       }
  //     }
  //   }
  //   return { matches, params, notFound };
}

// export function matchRouteTree2(
//   tree: RouteModuleTree,
//   pathname: string,
// ): MatchResult<RouteModuleTree> {
//   const prefixes = getPathPrefixes(pathname);

//   let node = tree;
//   const params: MatchParamEntry[] = [];
//   const matches: MatchNodeEntry<RouteModuleTree>[] = [];
//   let notFound = false;
//   for (let i = 0; i < prefixes.length; i++) {
//     const prefix = prefixes[i]!;
//     const segment = prefix.split("/").at(-1)!;
//     const next = matchRouteChild(segment, node);
//     if (next) {
//       node = next.child;
//       if (next.catchAll) {
//         const rest = pathname.slice(prefixes[i - 1]!.length + 1);
//         params.push([next.param, decodeURI(rest)]);
//         matches.push({ prefix: pathname, type: "layout", node, params });
//         break;
//       }
//       if (next.param) {
//         params.push([next.param, decodeURI(segment)]);
//       } else {
//         params.push([null, decodeURI(segment)]);
//       }
//     } else {
//       matches.push({ prefix, type: "not-found", node, params });
//       notFound = true;
//       break;
//     }
//     matches.push({ prefix, type: "layout", node, params });
//     if (prefix === pathname) {
//       if (node.value?.page) {
//         matches.push({ prefix, type: "page", node, params });
//       } else {
//         matches.push({ prefix, type: "not-found", node, params });
//         notFound = true;
//       }
//     }
//   }
//   return { matches, params, notFound };
// }

const DYNAMIC_RE = /^\[(\w*)\]$/;
const CATCH_ALL_RE = /^\[\.\.\.(\w*)\]$/;

function matchRouteChild<T>(input: string, node: TreeNode<T>) {
  if (!node.children) {
    return;
  }
  for (const [key, child] of Object.entries(node.children)) {
    const mAll = key.match(CATCH_ALL_RE);
    if (mAll) {
      tinyassert(1 in mAll);
      return { key, child, param: mAll[1], catchAll: true };
    }
    const m = key.match(DYNAMIC_RE);
    if (m) {
      tinyassert(1 in m);
      return { key, child, param: m[1] };
    }
    if (key === input) {
      return { key, child };
    }
  }
  return;
}

export function parseRoutePath(pathname: string) {
  const dynamicMap: Record<string, string> = {};

  for (const segment of pathname.split("/")) {
    const mAll = segment.match(CATCH_ALL_RE);
    if (mAll) {
      tinyassert(1 in mAll);
      mAll[1];
      dynamicMap[mAll[1]] = segment;
    }
    const m = segment.match(DYNAMIC_RE);
    if (m) {
      tinyassert(1 in m);
      dynamicMap[m[1]] = segment;
    }
  }

  function format(params: Record<string, string>): string {
    let result = pathname;
    tinyassert(
      isEqualArrayShallow(
        Object.keys(dynamicMap).sort(),
        Object.keys(params).sort(),
      ),
    );
    for (const [k, v] of Object.entries(params)) {
      const segment = dynamicMap[k];
      tinyassert(segment);
      result = result.replace(segment, v);
    }
    return result;
  }

  return {
    dynamic: Object.keys(dynamicMap).length > 0,
    format,
  };
}

function isEqualArrayShallow(xs: unknown[], ys: unknown[]) {
  return xs.length === ys.length && xs.every((x, i) => x === ys[i]);
}

//
// minimal basic tree structure
//

export type TreeNode<T> = {
  value?: T;
  children?: Record<string, TreeNode<T>>;
};

function initTreeNode<T>(): TreeNode<T> {
  return {};
}

function createTree<T>(entries: { value: T; keys: string[] }[]): TreeNode<T> {
  const root = initTreeNode<T>();

  for (const e of entries) {
    let node = root;
    for (const key of e.keys) {
      node = (node.children ??= {})[key] ??= initTreeNode();
    }
    node.value = e.value;
  }

  return root;
}

import { sortBy, tinyassert } from "@hiogawa/utils";
import type { AnyRouteModule } from "./server";
import { joinSegments, splitToSegments } from "./utils";

// generate tree from glob entries such as generated by
//   import.meta.glob("/**/(page|layout|...).(js|jsx|ts|tsx)")
export function createFsRouteTree<T>(globEntries: Record<string, unknown>): {
  entries: Record<string, T>;
  tree: TreeNode<T>;
} {
  const entries: Record<string, T> = {};
  for (const [k, v] of Object.entries(globEntries)) {
    const m = k.match(
      /^(.*)\/(page|layout|error|not-found|loading|template|route)\.\w*$/,
    );
    tinyassert(m && 1 in m && 2 in m);
    const pathname = m[1] || "/";
    (entries[pathname] ??= {} as any)[m[2]] = v;
  }

  const flatTree = Object.entries(entries).map(([k, v]) => ({
    keys: k.replace(/\/+$/, "").split("/"),
    value: v,
  }));
  const tree = createTree(flatTree);

  return { entries, tree };
}

export type MatchSegment =
  | {
      type: "static";
      value: string;
    }
  | {
      type: "dynamic";
      key: string;
      value: string;
    }
  | {
      type: "catchall";
      key: string;
      value: string;
    }
  | {
      type: "catchall-optional";
      key: string;
      value: string;
    }
  | {
      type: "group";
      value: string;
    }
  // the last match is guranteed to be one of the below
  | {
      type: "not-found";
      value: string;
    }
  | {
      type: "page";
    }
  | {
      type: "route";
    };

export type MatchParams = Record<string, string>;

export function toMatchParams(segments: MatchSegment[]): MatchParams {
  const params: MatchParams = {};
  for (const s of segments) {
    switch (s.type) {
      case "dynamic":
      case "catchall":
      case "catchall-optional":
        params[s.key] = s.value;
    }
  }
  return params;
}

export function toMatchValues(segments: MatchSegment[]): string[] {
  const values: string[] = [];
  for (const s of segments) {
    switch (s.type) {
      case "static":
      case "dynamic":
      case "catchall":
      case "catchall-optional":
      case "group":
      case "not-found":
        values.push(s.value);
    }
  }
  return values;
}

export function joinMatchSegments(segments: MatchSegment[]): string {
  return joinSegments(toMatchValues(segments));
}

type MatchEntry<T> = {
  node: TreeNode<T>;
  segment: MatchSegment;
};

export type PageMatchEntry<T> = {
  node: TreeNode<T>;
  id: string;
  /** not necessary an actual path as it includes group segment e.g. /x/(g)/z */
  path: string;
  type: PageMatchType;
  segments: MatchSegment[];
};

type PageMatchType = "layout" | "page" | "not-found";

export function toPageMatchType(s: MatchSegment): PageMatchType {
  switch (s.type) {
    case "not-found":
      return "not-found";
    case "page":
      return "page";
    case "route": {
      tinyassert(false, `unexpected 'route'`);
    }
  }
  return "layout";
}

export type MatchRouteResult<T> = {
  matches: PageMatchEntry<T>[];
  segments: MatchSegment[];
  notFound: boolean;
};

export function matchPageRoute<T extends AnyRouteModule>(
  tree: TreeNode<T>,
  pathname: string,
): MatchRouteResult<T> {
  const matches = matchRouteTree(tree, pathname, "page");
  // this assumes it has default not-found page at least
  tinyassert(matches && matches.length > 0);
  const segments = matches.map((m) => m.segment);
  const pageMatches = matches.map((m, i) => {
    const subSegments = segments.slice(0, i + 1);
    const path = joinMatchSegments(subSegments);
    const type = toPageMatchType(m.segment);
    const id = `${path}:${type}`;
    return {
      id,
      path,
      type,
      segments: subSegments,
      node: m.node,
    } satisfies PageMatchEntry<T>;
  });
  return {
    matches: pageMatches,
    segments,
    notFound: pageMatches.some((m) => m.type === "not-found"),
  };
}

export function matchRouteTree<T extends AnyRouteModule>(
  tree: TreeNode<T>,
  pathname: string,
  leafType: "page" | "route",
): MatchEntry<T>[] | undefined {
  const decodedSegments = splitToSegments(pathname).map((s) => decodeURI(s));
  return recurse(tree, decodedSegments);

  function recurse(
    node: TreeNode<T>,
    segments: string[],
  ): MatchEntry<T>[] | undefined {
    // try all branches for group routes
    const branches: MatchEntry<T>[][] = [];

    // check page or route
    if (segments.length === 0 && node.value?.[leafType]) {
      branches.push([
        {
          node: node,
          segment: {
            type: leafType,
          },
        },
      ]);
    }

    // recurse children
    for (const { match, nextSegments } of matchChildren(node, segments)) {
      const branch = recurse(match.node, nextSegments);
      if (branch) {
        branches.push([match, ...branch]);
      }
    }

    // check not-found
    if (branches.length === 0 && node.value?.["not-found"]) {
      return [
        {
          node,
          segment: {
            type: "not-found",
            value: segments.join("/"),
          },
        },
      ];
    }

    // tie break branches
    return sortBy(branches, (b) => scoreBranch(b))[0];
  }
}

function scoreBranch<T>(branch: MatchEntry<T>[]) {
  const first = branch[0]?.segment.type;
  const last = branch.at(-1)?.segment.type;
  tinyassert(first && last);
  let score = 0;
  // TODO: research and rework not-found tie-break
  if (last === "not-found") score += 10;
  // static = group < dynamic < catchall
  if (first === "dynamic") score += 2;
  if (first === "catchall") score += 3;
  if (first === "catchall-optional") score += 4;
  return score;
}

function matchChildren<T>(node: TreeNode<T>, segments: string[]) {
  const candidates: {
    match: { node: TreeNode<T>; segment: MatchSegment };
    nextSegments: string[];
  }[] = [];
  for (const [key, child] of Object.entries(node.children ?? {})) {
    const mGroup = key.match(GROUP_RE);
    if (mGroup) {
      candidates.push({
        match: {
          node: child,
          segment: {
            type: "group",
            value: key,
          },
        },
        nextSegments: segments,
      });
    }
    const matchCatchAll = key.match(CATCH_ALL_RE);
    if (matchCatchAll && segments.length > 0) {
      candidates.push({
        match: {
          node: child,
          segment: {
            type: "catchall",
            key: matchCatchAll[1]!,
            value: segments.join("/"),
          },
        },
        nextSegments: [],
      });
    }
    const matchCatchAllOpt = key.match(CATCH_ALL_OPTIONAL_RE);
    if (matchCatchAllOpt) {
      candidates.push({
        match: {
          node: child,
          segment: {
            type: "catchall-optional",
            key: matchCatchAllOpt[1]!,
            value: segments.join("/"),
          },
        },
        nextSegments: [],
      });
    }
    const matchDynamic = key.match(DYNAMIC_RE);
    if (matchDynamic) {
      candidates.push({
        match: {
          node: child,
          segment: {
            type: "dynamic",
            key: matchDynamic[1]!,
            value: segments[0]!,
          },
        },
        nextSegments: segments.slice(1),
      });
    }
    if (key === segments[0]) {
      candidates.push({
        match: {
          node: child,
          segment: {
            type: "static",
            value: segments[0]!,
          },
        },
        nextSegments: segments.slice(1),
      });
    }
  }
  return candidates;
}

const DYNAMIC_RE = /^\[(\w*)\]$/;
const CATCH_ALL_RE = /^\[\.\.\.(\w*)\]$/;
const CATCH_ALL_OPTIONAL_RE = /^\[\[\.\.\.(\w*)\]\]$/;
const GROUP_RE = /^\((\w+)\)$/;

export function parseRoutePath(pathname: string) {
  const dynamicMap: Record<string, string> = {};

  for (const segment of pathname.split("/")) {
    const mGroup = segment.match(GROUP_RE);
    if (mGroup) {
      // strip off group segment
      pathname = pathname.replace(`/${segment}`, "");
    }
    // TODO: optional catch-all
    const mAll = segment.match(CATCH_ALL_RE);
    if (mAll) {
      tinyassert(1 in mAll);
      dynamicMap[mAll[1]] = segment;
    }
    const m = segment.match(DYNAMIC_RE);
    if (m) {
      tinyassert(1 in m);
      dynamicMap[m[1]] = segment;
    }
  }

  function format(params: Record<string, string>): string {
    let result = pathname;
    tinyassert(
      isEqualArrayShallow(
        Object.keys(dynamicMap).sort(),
        Object.keys(params).sort(),
      ),
    );
    for (const [k, v] of Object.entries(params)) {
      const segment = dynamicMap[k];
      tinyassert(segment);
      result = result.replace(segment, v);
    }
    return result;
  }

  return {
    dynamic: Object.keys(dynamicMap).length > 0,
    format,
  };
}

function isEqualArrayShallow(xs: unknown[], ys: unknown[]) {
  return xs.length === ys.length && xs.every((x, i) => x === ys[i]);
}

//
// minimal basic tree structure
//

export type TreeNode<T> = {
  value?: T;
  children?: Record<string, TreeNode<T>>;
};

function initTreeNode<T>(): TreeNode<T> {
  return {};
}

function createTree<T>(entries: { value: T; keys: string[] }[]): TreeNode<T> {
  const root = initTreeNode<T>();

  for (const e of entries) {
    let node = root;
    for (const key of e.keys) {
      node = (node.children ??= {})[key] ??= initTreeNode();
    }
    node.value = e.value;
  }

  return root;
}
